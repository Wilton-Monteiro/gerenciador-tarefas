name: Deploy Automatizado com SonarQube

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-analyze-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout do c√≥digo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login no Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}

      - name: Build e push da imagem Docker
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            willmonteiro/gerenciador-tarefas:01
            willmonteiro/gerenciador-tarefas:latest
            willmonteiro/gerenciador-tarefas:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Setup da chave SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Start SonarQube tempor√°rio no servidor remoto
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            # Limpar containers anteriores
            docker stop sonarqube-temp 2>/dev/null || true
            docker rm sonarqube-temp 2>/dev/null || true

            # Remover volumes antigos se existirem
            docker volume rm sonarqube_data sonarqube_logs sonarqube_extensions 2>/dev/null || true

            # Configurar limits do sistema para Elasticsearch
            echo "Configurando limites do sistema..."
            sudo sysctl -w vm.max_map_count=262144 2>/dev/null || echo "Aviso: N√£o foi poss√≠vel configurar vm.max_map_count"

            # Configura√ß√µes otimizadas com Elasticsearch embarcado
            echo "Iniciando SonarQube com configura√ß√µes otimizadas..."
            docker run -d --name sonarqube-temp -p 9000:9000 \
              -e SONAR_ES_BOOTSTRAP_CHECKS_DISABLE=true \
              -e SONAR_WEB_JAVAADDITIONALOPTS="-Xmx1536m -Xms512m -XX:+UseG1GC" \
              -e SONAR_CE_JAVAADDITIONALOPTS="-Xmx1024m -Xms512m -XX:+UseG1GC" \
              -e SONAR_SEARCH_JAVAADDITIONALOPTS="-Xmx1024m -Xms512m -XX:+UseG1GC" \
              -v sonarqube_data:/opt/sonarqube/data \
              -v sonarqube_logs:/opt/sonarqube/logs \
              -v sonarqube_extensions:/opt/sonarqube/extensions \
              --memory=3g \
              --memory-swap=3g \
              --oom-kill-disable=false \
              --ulimit nofile=65536:65536 \
              --ulimit nproc=4096:4096 \
              sonarqube:lts-community

            echo "Aguardando SonarQube iniciar completamente..."
            TIMEOUT=120
            for i in $(seq 1 $TIMEOUT); do
              # Verificar se o container ainda est√° rodando
              if ! docker ps | grep -q sonarqube-temp; then
                echo "‚ùå Container SonarQube parou de funcionar!"
                echo "=== LOGS DO CONTAINER ==="
                docker logs sonarqube-temp --tail 50
                exit 1
              fi

              # Verificar status da API
              if curl -s --connect-timeout 5 --max-time 10 http://localhost:9000/api/system/status 2>/dev/null | grep -q '"status":"UP"'; then
                echo "‚úÖ SonarQube est√° pronto! ($i/$TIMEOUT)"
                # Aguardar mais um pouco para garantir estabilidade
                sleep 15
                
                # Verificar novamente para garantir
                if curl -s http://localhost:9000/api/system/status 2>/dev/null | grep -q '"status":"UP"'; then
                  echo "‚úÖ Confirmado: SonarQube totalmente operacional!"
                  exit 0
                fi
              fi
              
              if [ $((i % 10)) -eq 0 ]; then
                echo "Aguardando SonarQube... ($i/$TIMEOUT)"
                echo "Status do container: $(docker ps --filter name=sonarqube-temp --format 'table {{.Status}}')"
              fi
              sleep 5
            done
            
            echo "‚ùå Timeout esperando SonarQube ($TIMEOUT tentativas)"
            echo "=== STATUS DO CONTAINER ==="
            docker ps -a | grep sonarqube-temp
            echo "=== LOGS COMPLETOS ==="
            docker logs sonarqube-temp --tail 100
            exit 1
          EOF

      - name: Instalar SonarQube Scanner
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - run: npm install -g sonarqube-scanner

      - name: Aguardar SonarQube estar totalmente pronto
        run: |
          echo "Verifica√ß√£o final antes da an√°lise..."
          for i in {1..10}; do
            STATUS=$(curl -s --connect-timeout 10 --max-time 15 "http://${{ secrets.SERVER_HOST }}:9000/api/system/status" 2>/dev/null | jq -r '.status' 2>/dev/null || echo "DOWN")
            if [ "$STATUS" == "UP" ]; then
              echo "‚úÖ SonarQube confirmado como pronto!"
              break
            fi
            echo "Aguardando confirma√ß√£o final... ($i/10)"
            sleep 10
          done

      - name: Rodar an√°lise SonarQube
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: http://${{ secrets.SERVER_HOST }}:9000
        run: |
          echo "Iniciando an√°lise SonarQube..."
          sonar-scanner \
            -Dsonar.projectKey=gerenciador-tarefas \
            -Dsonar.projectName="Gerenciador de Tarefas" \
            -Dsonar.projectVersion=1.0 \
            -Dsonar.sources=. \
            -Dsonar.host.url=$SONAR_HOST_URL \
            -Dsonar.login=$SONAR_TOKEN \
            -Dsonar.exclusions=**/node_modules/**,**/*.log,front-end/styles.css,**/*.md,**/*.txt,**/*.json \
            -Dsonar.sourceEncoding=UTF-8 \
            -Dsonar.scm.provider=git \
            -Dsonar.verbose=false

      - name: Verificar Quality Gate
        run: |
          echo "Aguardando processamento da an√°lise..."
          sleep 30
          
          for i in {1..15}; do
            RESPONSE=$(curl -s -u ${{ secrets.SONAR_TOKEN }}: "http://${{ secrets.SERVER_HOST }}:9000/api/qualitygates/project_status?projectKey=gerenciador-tarefas" 2>/dev/null || echo '{"projectStatus":{"status":"PENDING"}}')
            STATUS=$(echo "$RESPONSE" | jq -r '.projectStatus.status' 2>/dev/null || echo "PENDING")
            
            echo "Tentativa $i/15: Status Quality Gate = $STATUS"
            
            if [ "$STATUS" == "OK" ]; then
              echo "‚úÖ Quality Gate passou com sucesso!"
              exit 0
            elif [ "$STATUS" == "ERROR" ]; then
              echo "‚ùå Quality Gate falhou!"
              echo "Detalhes do erro:"
              echo "$RESPONSE" | jq '.' 2>/dev/null || echo "$RESPONSE"
              exit 1
            elif [ "$STATUS" == "NONE" ]; then
              echo "‚ö†Ô∏è  Quality Gate n√£o configurado - continuando..."
              exit 0
            else
              echo "Status: $STATUS - Aguardando an√°lise concluir..."
              sleep 20
            fi
          done
          echo "‚ùå Timeout aguardando Quality Gate (5 minutos)"
          exit 1

      - name: Parar e limpar SonarQube tempor√°rio
        if: always()
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            echo "Limpando recursos do SonarQube tempor√°rio..."
            docker stop sonarqube-temp 2>/dev/null || true
            docker rm sonarqube-temp 2>/dev/null || true
            # Limpar volumes tempor√°rios para economizar espa√ßo
            docker volume rm sonarqube_data sonarqube_logs sonarqube_extensions 2>/dev/null || true
            # Limpar imagens n√£o utilizadas
            docker image prune -f 2>/dev/null || true
            echo "‚úÖ Limpeza conclu√≠da"
          EOF

      - name: Deploy no servidor remoto
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} 'bash -s' << 'EOF'
          echo "Iniciando deploy da aplica√ß√£o..."
          
          # Parar aplica√ß√£o atual
          docker-compose -f /home/aluno/gerenciador-tarefas/docker-compose.yml down || true
          
          # Limpar imagens antigas
          docker rmi willmonteiro/gerenciador-tarefas:01 || true
          docker rmi willmonteiro/gerenciador-tarefas:latest || true

          # Criar diret√≥rio se n√£o existir
          mkdir -p /home/aluno/gerenciador-tarefas

          # Baixar nova imagem
          docker pull willmonteiro/gerenciador-tarefas:01

          # Criar docker-compose.yml atualizado
          cat > /home/aluno/gerenciador-tarefas/docker-compose.yml << 'DOCKERCOMPOSE'
          version: '3.8'

          services:
            app:
              image: willmonteiro/gerenciador-tarefas:01
              ports:
                - "3001:3000"
              depends_on:
                db:
                  condition: service_healthy
              environment:
                - DB_HOST=db
                - DB_PORT=5432
                - DB_NAME=tarefas_db
                - DB_USER=postgres
                - DB_PASSWORD=postgres123
                - NODE_ENV=production
              networks:
                - app-network
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
                interval: 30s
                timeout: 10s
                retries: 3

            db:
              image: postgres:15-alpine
              environment:
                - POSTGRES_DB=tarefas_db
                - POSTGRES_USER=postgres
                - POSTGRES_PASSWORD=postgres123
                - POSTGRES_INITDB_ARGS=--encoding=UTF-8 --lc-collate=C --lc-ctype=C
              ports:
                - "5435:5432"
              volumes:
                - postgres_data:/var/lib/postgresql/data
              networks:
                - app-network
              restart: unless-stopped
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U postgres"]
                interval: 10s
                timeout: 5s
                retries: 5

          volumes:
            postgres_data:

          networks:
            app-network:
              driver: bridge
          DOCKERCOMPOSE

          # Subir nova vers√£o
          cd /home/aluno/gerenciador-tarefas
          docker-compose up -d
          
          echo "‚úÖ Deploy conclu√≠do!"
          EOF

      - name: Verificar aplica√ß√£o online
        run: |
          echo "Aguardando aplica√ß√£o inicializar..."
          sleep 30
          
          for i in {1..10}; do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 10 --max-time 15 "http://${{ secrets.SERVER_HOST }}:3001" || echo "000")
            echo "Tentativa $i/10: Status HTTP = $STATUS"
            
            if [ "$STATUS" = "200" ] || [ "$STATUS" = "302" ] || [ "$STATUS" = "301" ]; then
              echo "‚úÖ Aplica√ß√£o est√° online e funcionando!"
              echo "üåê Acesse: http://${{ secrets.SERVER_HOST }}:3001"
              exit 0
            fi
            
            echo "Aguardando aplica√ß√£o... ($i/10)"
            sleep 15
          done
          
          echo "‚ùå Erro: Aplica√ß√£o n√£o respondeu corretamente"
          echo "Verificando logs para diagn√≥stico..."
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            echo "=== STATUS DOS CONTAINERS ==="
            docker-compose -f /home/aluno/gerenciador-tarefas/docker-compose.yml ps
            echo "=== LOGS DA APLICA√á√ÉO ==="
            docker-compose -f /home/aluno/gerenciador-tarefas/docker-compose.yml logs --tail 20 app
          EOF
          exit 1