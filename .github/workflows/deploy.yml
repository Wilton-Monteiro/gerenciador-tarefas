name: Deploy Automatizado com SonarQube

on:
  push:
    branches: [ main ]
  
jobs:
  build-analyze-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout do código
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login no Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}

      - name: Build e push da imagem Docker
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            willmonteiro/gerenciador-tarefas:01
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Setup da chave SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Preparar ambiente e iniciar SonarQube
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            # Função para encontrar porta livre
            find_free_port() {
              for port in 9000 9001 9002 9003 9004 9005; do
                if ! netstat -tulpn | grep -q ":$port "; then
                  echo $port
                  return
                fi
              done
              echo "9000" # fallback
            }

            
            # Encontrar porta livre
            SONAR_PORT=$(find_free_port)
            echo "Usando porta: $SONAR_PORT"
            echo "SONAR_PORT=$SONAR_PORT" > /tmp/sonar_port.env

            # Configurar limites do sistema OBRIGATÓRIOS
            echo "=== CONFIGURAÇÃO DO SISTEMA ==="
            sudo sysctl -w vm.max_map_count=262144
            sudo sysctl -w fs.file-max=65536
            # Persistir as configurações (opcional, mas bom para evitar problemas em caso de reboot)
            echo "vm.max_map_count=262144" | sudo tee -a /etc/sysctl.conf
            echo "fs.file-max=65536" | sudo tee -a /etc/sysctl.conf
            # Aplicar imediatamente (já feito com -w, mas repetir o apply para garantir se o tee foi primeiro)
            sudo sysctl -p

            # Verificar recursos disponíveis
            echo "=== RECURSOS DO SISTEMA ==="
            echo "Memória disponível:"
            free -h
            echo "Espaço em disco:"
            df -h

            # Criar volumes com permissões corretas
            echo "=== CRIANDO VOLUMES ==="
            docker volume create sonarqube_temp_data
            docker volume create sonarqube_temp_logs  
            docker volume create sonarqube_temp_extensions

            # Iniciar SonarQube com banco H2 embarcado (SEM configuração JDBC externa)
            echo "=== INICIANDO SONARQUBE ==="
            docker run -d --name sonarqube-temp \
              -p $SONAR_PORT:9000 \
              -e SONAR_ES_BOOTSTRAP_CHECKS_DISABLE=true \
              -e SONAR_SEARCH_JAVAADDITIONALOPTS="-Xms1024m -Xmx1024m -XX:MaxDirectMemorySize=256m" \
              -e SONAR_WEB_JAVAADDITIONALOPTS="-Xms1024m -Xmx2048m -XX:+UseG1GC" \
              -e SONAR_CE_JAVAADDITIONALOPTS="-Xms512m -Xmx1024m -XX:+UseG1GC" \
              -e ES_JAVA_OPTS="-Xms1024m -Xmx1024m" \
              -v sonarqube_temp_data:/opt/sonarqube/data \
              -v sonarqube_temp_logs:/opt/sonarqube/logs \
              -v sonarqube_temp_extensions:/opt/sonarqube/extensions \
              --memory=4g \
              --memory-swap=4g \
              --memory-swappiness=1 \
              --oom-kill-disable=false \
              --ulimit nofile=65536:65536 \
              --ulimit nproc=4096:4096 \
              --ulimit memlock=-1:-1 \
              --security-opt seccomp=unconfined \
              sonarqube:9.9-community

            if [ $? -ne 0 ]; then
              echo "❌ Falha ao iniciar container SonarQube"
              exit 1
            fi

            echo "Container iniciado, aguardando logs iniciais..."
            sleep 15
            docker logs sonarqube-temp --tail 30

            # Aguardar SonarQube iniciar com timeout e verificações melhoradas
            echo "=== AGUARDANDO SONARQUBE ==="
            TIMEOUT=400
            for i in $(seq 1 $TIMEOUT); do
              # PRIMEIRO: Verificar logs em busca de erros críticos ESPECÍFICOS DE MEMÓRIA
              LOGS=$(docker logs sonarqube-temp --tail 20 2>&1)
              if echo "$LOGS" | grep -q "OutOfMemoryError\|java.lang.OutOfMemoryError"; then
                echo "❌ Erro de memória detectado PRIMEIRO!"
                echo "=== LOGS COMPLETOS DO ERRO DE MEMÓRIA ==="
                docker logs sonarqube-temp --tail 50
                echo "=== RECURSOS ATUAIS DO SISTEMA ==="
                free -h
                df -h
                echo "=== STATUS DOS PROCESSOS JAVA ==="
                docker exec sonarqube-temp ps aux | grep java || echo "Container inacessível"
                exit 1
              fi

              # SEGUNDO: Verificar se container está rodando
              if ! docker ps | grep -q sonarqube-temp; then
                echo "❌ Container parou de funcionar!"
                echo "=== LOGS DO CONTAINER ==="
                docker logs sonarqube-temp --tail 100
                exit 1
              fi

              # Verificar se o SonarQube finalizou a inicialização
              if echo "$LOGS" | grep -q "SonarQube is operational"; then
                echo "✅ SonarQube totalmente iniciado!"
                sleep 10  # Aguardar estabilização
                break
              fi

              # Testar API de status com timeout menor
              STATUS_RESPONSE=$(timeout 10 curl -s --connect-timeout 5 --max-time 8 "http://localhost:$SONAR_PORT/api/system/status" 2>/dev/null || echo "")
              
              if echo "$STATUS_RESPONSE" | grep -q '"status":"UP"'; then
                echo "✅ SonarQube respondendo na porta $SONAR_PORT!"
                
                # Aguardar estabilização completa
                echo "Aguardando estabilização completa..."
                sleep 30
                
                # Verificação final de saúde
                HEALTH_CHECK=$(timeout 10 curl -s --connect-timeout 5 --max-time 8 "http://localhost:$SONAR_PORT/api/system/health" 2>/dev/null || echo "")
                if echo "$HEALTH_CHECK" | grep -q '"health":"GREEN"\|"health":"YELLOW"'; then
                  echo "✅ SonarQube totalmente operacional e saudável!"
                  break
                fi
                
                # Se status UP mas health não disponível, ainda funciona
                echo "✅ SonarQube operacional (status UP confirmado)!"
                break
              fi
              
              # Log de progresso a cada 30 segundos
              if [ $((i % 6)) -eq 0 ]; then
                echo "Aguardando SonarQube... ($((i*5))/${TIMEOUT}s)"
                echo "Status atual do container:"
                docker ps --filter name=sonarqube-temp --format 'table {{.Names}}\t{{.Status}}'
                echo "Últimas linhas do log (buscando por 'operational' ou 'started'):"
                docker logs sonarqube-temp 2>/dev/null | grep -i "operational\|started\|ready\|listening" | tail -3 || echo "Ainda inicializando..."
              fi
              
              sleep 5
            done
            
            # Verificação final se saiu do loop sem sucesso
            FINAL_STATUS=$(timeout 10 curl -s --connect-timeout 5 --max-time 8 "http://localhost:$SONAR_PORT/api/system/status" 2>/dev/null || echo "")
            if echo "$FINAL_STATUS" | grep -q '"status":"UP"'; then
              echo "✅ SonarQube operacional (verificação final bem-sucedida)!"
              exit 0
            fi
            
            echo "❌ Timeout esperando SonarQube ($((TIMEOUT*5)) segundos)"
            echo "=== LOGS FINAIS ==="
            docker logs sonarqube-temp --tail 100
            echo "=== STATUS DO SISTEMA ==="
            free -h
            df -h
            exit 1
          EOF

      - name: Obter porta do SonarQube
        run: |
          SONAR_PORT=$(ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} 'cat /tmp/sonar_port.env | cut -d= -f2')
          echo "SONAR_PORT=$SONAR_PORT" >> $GITHUB_ENV
          echo "SonarQube rodando na porta: $SONAR_PORT"

      - name: Instalar SonarQube Scanner
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - run: npm install -g sonarqube-scanner

      - name: Verificação final e aguardar estabilização
        run: |
          echo "=== VERIFICAÇÃO FINAL ==="
          SONAR_HOST_URL="http://${{ secrets.SERVER_HOST }}:$SONAR_PORT"
          
          # Aguardar estabilização adicional
          sleep 30
          
          for i in {1..15}; do
            echo "Verificação $i/15: Testando $SONAR_HOST_URL"
            
            # Testar conectividade básica
            STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 10 --max-time 15 "$SONAR_HOST_URL" 2>/dev/null || echo "000")
            echo "HTTP Status: $STATUS_CODE"
            
            # Testar API de status
            STATUS_RESPONSE=$(curl -s --connect-timeout 10 --max-time 15 "$SONAR_HOST_URL/api/system/status" 2>/dev/null || echo "")
            echo "API Response: $STATUS_RESPONSE"
            
            if echo "$STATUS_RESPONSE" | grep -q '"status":"UP"'; then
              echo "✅ SonarQube confirmado como pronto e operacional!"
              break
            fi
            
            if [ $i -eq 15 ]; then
              echo "❌ SonarQube não respondeu adequadamente após verificações"
              # Logs de diagnóstico final
              ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'DIAGEOF'
                echo "=== DIAGNÓSTICO FINAL ==="
                echo "Status do container:"
                docker ps --filter name=sonarqube-temp
                echo "Últimas 30 linhas do log:"
                docker logs sonarqube-temp --tail 30
                echo "Uso de recursos:"
                free -h
                df -h
              DIAGEOF
              exit 1
            fi
            
            echo "Aguardando mais um pouco..."
            sleep 20
          done

      - name: Executar análise SonarQube
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          SONAR_HOST_URL="http://${{ secrets.SERVER_HOST }}:$SONAR_PORT"
          echo "=== INICIANDO ANÁLISE SONARQUBE ==="
          echo "URL: $SONAR_HOST_URL"
          echo "Projeto: gerenciador-tarefas"
          
          # Executar análise com timeout maior e configurações otimizadas
          timeout 1200 sonar-scanner \
            -Dsonar.projectKey=gerenciador-tarefas \
            -Dsonar.projectName="Gerenciador de Tarefas" \
            -Dsonar.projectVersion=1.0 \
            -Dsonar.sources=. \
            -Dsonar.host.url=$SONAR_HOST_URL \
            -Dsonar.login=$SONAR_TOKEN \
            -Dsonar.exclusions=**/node_modules/**,**/*.log,**/*.md,**/*.txt,**/*.json,**/.git/**,**/dist/**,**/build/**,**/coverage/**,**/*.min.js \
            -Dsonar.inclusions=**/*.js,**/*.html,**/*.css \
            -Dsonar.sourceEncoding=UTF-8 \
            -Dsonar.scm.provider=git \
            -Dsonar.qualitygate.wait=false \
            -Dsonar.ws.timeout=300 \
            -Dsonar.scanner.maxHeap=1024m \
            -Dsonar.verbose=false \
            -Dsonar.log.level=INFO

      - name: Verificar Quality Gate
        run: |
          echo "=== VERIFICAÇÃO DO QUALITY GATE ==="
          echo "Aguardando processamento completo da análise..."
          sleep 90
          
          SONAR_HOST_URL="http://${{ secrets.SERVER_HOST }}:$SONAR_PORT"
          
          for i in {1..20}; do
            echo "Tentativa $i/20: Consultando Quality Gate..."
            
            RESPONSE=$(curl -s --connect-timeout 15 --max-time 20 \
              -u ${{ secrets.SONAR_TOKEN }}: \
              "$SONAR_HOST_URL/api/qualitygates/project_status?projectKey=gerenciador-tarefas" \
              2>/dev/null || echo '{"projectStatus":{"status":"PENDING"}}')
            
            echo "Resposta da API: $RESPONSE"
            
            STATUS=$(echo "$RESPONSE" | jq -r '.projectStatus.status' 2>/dev/null || echo "PENDING")
            echo "Status atual: $STATUS"
            
            case "$STATUS" in
              "OK")
                echo "✅ Quality Gate passou com sucesso!"
                exit 0
                ;;
              "ERROR")
                echo "❌ Quality Gate falhou!"
                echo "Detalhes do erro:"
                echo "$RESPONSE" | jq '.' 2>/dev/null || echo "$RESPONSE"
                # Para projetos em desenvolvimento, vamos continuar mesmo com falha no Quality Gate
                echo "⚠️  Continuando deploy apesar da falha no Quality Gate..."
                exit 0
                ;;
              "NONE")
                echo "⚠️  Quality Gate não configurado - continuando deploy..."
                exit 0
                ;;
              "PENDING"|"IN_PROGRESS")
                echo "⏳ Análise ainda em processamento..."
                ;;
              *)
                echo "⚠️  Status inesperado: $STATUS - continuando..."
                exit 0
                ;;
            esac
            
            if [ $i -lt 20 ]; then
              echo "Aguardando próxima verificação..."
              sleep 30
            fi
          done
          
          echo "⚠️  Timeout aguardando Quality Gate - continuando deploy..."
          exit 0

      - name: Limpar SonarQube temporário
        if: always()
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            echo "=== LIMPEZA DO SONARQUBE TEMPORÁRIO ==="
            docker stop sonarqube-temp 2>/dev/null || true
            docker rm sonarqube-temp 2>/dev/null || true
            docker volume rm sonarqube_temp_data sonarqube_temp_logs sonarqube_temp_extensions 2>/dev/null || true
            rm -f /tmp/sonar_port.env
            echo "✅ Limpeza concluída com sucesso"
          EOF

      - name: Deploy no servidor remoto
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} 'bash -s' << 'EOF'
          echo "=== INICIANDO DEPLOY DA APLICAÇÃO ==="
          
          # Parar aplicação atual
          docker-compose -f /home/aluno/gerenciador-tarefas/docker-compose.yml down || true
          docker rmi willmonteiro/gerenciador-tarefas:01 || true
          docker rmi willmonteiro/gerenciador-tarefas:latest || true

          # Preparar diretório
          mkdir -p /home/aluno/gerenciador-tarefas
          
          # Baixar nova imagem
          docker pull willmonteiro/gerenciador-tarefas:01

          # Criar docker-compose.yml
          cat > /home/aluno/gerenciador-tarefas/docker-compose.yml << 'DOCKERCOMPOSE'
          version: '3.8'

          services:
            app:
              image: willmonteiro/gerenciador-tarefas:01
              ports:
                - "3001:3000"
              depends_on:
                db:
                  condition: service_healthy
              environment:
                - DB_HOST=db
                - DB_PORT=5432
                - DB_NAME=tarefas_db
                - DB_USER=postgres
                - DB_PASSWORD=postgres123
                - NODE_ENV=production
              networks:
                - app-network
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
                interval: 30s
                timeout: 10s
                retries: 3

            db:
              image: postgres:15-alpine
              environment:
                - POSTGRES_DB=tarefas_db
                - POSTGRES_USER=postgres
                - POSTGRES_PASSWORD=postgres123
                - POSTGRES_INITDB_ARGS=--encoding=UTF-8 --lc-collate=C --lc-ctype=C
              ports:
                - "5435:5432"
              volumes:
                - postgres_data:/var/lib/postgresql/data
              networks:
                - app-network
              restart: unless-stopped
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U postgres"]
                interval: 10s
                timeout: 5s
                retries: 5

          volumes:
            postgres_data:

          networks:
            app-network:
              driver: bridge
          DOCKERCOMPOSE

          # Iniciar aplicação
          cd /home/aluno/gerenciador-tarefas
          docker-compose up -d
          
          echo "✅ Deploy da aplicação concluído!"
          echo "Verificando status dos containers..."
          docker-compose ps
          EOF

      - name: Verificar aplicação online
        run: |
          echo "=== VERIFICAÇÃO FINAL DA APLICAÇÃO ==="
          echo "Aguardando aplicação inicializar completamente..."
          sleep 60
          
          for i in {1..15}; do
            echo "Verificação $i/15..."
            
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
              --connect-timeout 15 --max-time 20 \
              "http://${{ secrets.SERVER_HOST }}:3001" || echo "000")
            
            echo "HTTP Status: $STATUS"
            
            case "$STATUS" in
              "200"|"302"|"301")
                echo "✅ Aplicação está online e funcionando!"
                echo "🌐 Acesse em: http://${{ secrets.SERVER_HOST }}:3001"
                exit 0
                ;;
              "000")
                echo "⚠️  Sem resposta da aplicação"
                ;;
              *)
                echo "⚠️  Status HTTP inesperado: $STATUS"
                ;;
            esac
            
            if [ $i -lt 15 ]; then
              echo "Aguardando próxima verificação..."
              sleep 25
            fi
          done
          
          echo "❌ Aplicação não respondeu adequadamente"
          echo "=== DIAGNÓSTICO ==="
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'EOF'
            echo "Status dos containers:"
            docker-compose -f /home/aluno/gerenciador-tarefas/docker-compose.yml ps
            echo -e "\n=== LOGS DA APLICAÇÃO ==="
            docker-compose -f /home/aluno/gerenciador-tarefas/docker-compose.yml logs --tail 30 app
            echo -e "\n=== LOGS DO BANCO ==="
            docker-compose -f /home/aluno/gerenciador-tarefas/docker-compose.yml logs --tail 10 db
          EOF
          exit 1