name: Deploy Automatizado com SonarQube

on:
  push:
    branches:
      - main

jobs:
  build-analyze-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout do código
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login no Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}

      - name: Build e push da imagem Docker
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: willmonteiro/gerenciador-tarefas:01
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Configurar chave SSH no agente
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Parar e remover SonarQube temporário (caso exista)
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} '
            docker stop sonarqube-temp || true
            docker rm sonarqube-temp || true
          '

      - name: Iniciar SonarQube temporário no servidor remoto
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} '
            docker pull sonarqube:9.9-community
            docker run -d --name sonarqube-temp -p 9000:9000 \
              -e SONAR_ES_BOOTSTRAP_CHECKS_DISABLE=true \
              --memory=3g \
              --ulimit nofile=65536:65536 \
              sonarqube:9.9-community
          '

      - name: Aguardar SonarQube inicializar via API
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} '
            echo "Aguardando SonarQube atingir status UP..."
            for i in {1..60}; do
              STATUS=$(curl -s http://localhost:9000/api/system/status | grep -oP "\"status\":\"\K[^\"]+")
              echo "Status atual: $STATUS"
              if [ "$STATUS" = "UP" ]; then
                echo "SonarQube está UP."
                exit 0
              fi
              sleep 10
            done
            echo "Timeout esperando SonarQube subir."
            docker logs sonarqube-temp --tail 20
            exit 1
          '

      - name: Copiar projeto para o servidor remoto
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} 'rm -rf ~/projeto-tarefas'
          scp -r . ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:~/projeto-tarefas

      - name: Instalar e executar SonarScanner no servidor remoto
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} '
            mkdir -p $HOME/sonar
            cd $HOME/sonar
            if [ ! -d "sonar-scanner-4.8.0.2856-linux" ]; then
              wget -q -O sonar-scanner.tar.gz https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-4.8.0.2856-linux.tar.gz
              tar -xzf sonar-scanner.tar.gz
            fi
            cd $HOME/projeto-tarefas
            if [ ! -f sonar-project.properties ]; then
              echo "Arquivo sonar-project.properties não encontrado!"
              exit 1
            fi
            $HOME/sonar/sonar-scanner-4.8.0.2856-linux/bin/sonar-scanner
          '

      - name: Parar e remover SonarQube temporário
        if: always()
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} '
            docker stop sonarqube-temp || true
            docker rm sonarqube-temp || true
          '

      - name: Deploy da aplicação com Docker Compose
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} '
            mkdir -p ~/projeto-tarefas-deploy
            cd ~/projeto-tarefas-deploy
            # Parar e remover containers antigos
            docker compose down || true

            # Criar arquivo docker-compose.yml (ajuste conforme necessário)
            cat > docker-compose.yml <<EOF
            version: "3.8"
            services:
              postgres-db:
                image: postgres:15-alpine
                environment:
                  POSTGRES_DB: tarefas_db
                  POSTGRES_USER: postgres
                  POSTGRES_PASSWORD: postgres123
                volumes:
                  - postgres_data:/var/lib/postgresql/data
                networks:
                  - app-network

              gerenciador-tarefas:
                image: willmonteiro/gerenciador-tarefas:01
                ports:
                  - "8248-8253:3000"
                environment:
                  DB_HOST: postgres-db
                  DB_PORT: 5432
                  DB_NAME: tarefas_db
                  DB_USER: postgres
                  DB_PASSWORD: postgres123
                  NODE_ENV: production
                networks:
                  - app-network
                depends_on:
                  - postgres-db

            volumes:
              postgres_data:

            networks:
              app-network:
            EOF

            # Subir containers
            docker compose up -d --build
          '

      - name: Verificar aplicação no intervalo de portas 8248-8253
        run: |
          echo "Aguardando aplicação inicializar..."
          sleep 30
          for port in {8248..8253}; do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.SERVER_HOST }}:$port || echo "000")
            if [ "$STATUS" = "200" ] || [ "$STATUS" = "302" ]; then
              echo "✅ Aplicação online em http://${{ secrets.SERVER_HOST }}:$port"
              exit 0
            fi
          done
          echo "❌ Aplicação não respondeu em nenhuma porta do intervalo 8248-8253"
          exit 1
